定義指示書/粒子と素粒子の関係について

# TODO
- コードと仕様書が異なっているので仕様書への追加項目を洗い出さないといけない
- attractive , repulsive forceを周期境界条件の向こう側でも効かせる必要がある


# 目的
- 一つの系を定義しその活動を可視化するプログラムをp5jsにて生成する
- JavaScriptはES6で生成
- できるだけ関数を分割し、独立性を高め、純粋関数を利用する

# 基本概念:
## 系の定義
- 系は二次元である
- 系の左端と右端はつながっている周期境界条件である
- 系の上端と下端はつながっている周期境界条件である
- よって系内部に定義されたベクトル場もつながっている周期境界条件である
- 全ての粒子の素粒子の運動は周期境界条件を前提とする

## 系の構成物
- 系には、以下の構成物が存在持している
  - 正エネルギーを持つ粒子P
  - 空間の正のエネルギーをつかさどる素粒子mu
  - 負のエネルギーを持つ粒子N
  - 空間の負のエネルギーをつかさどる素粒子qi

## 粒子と素粒子の性質
- 粒子P,Nは大きさと重さmを持つ。半径はrの二次元球である。
- 素粒子は大きさを持たない
- 粒子P,Nは誕生したり、消滅したりする。アリゴリズムは後述する
- 系のエネルギーは一定である
- 系のエネルギーはE(total)= Epp + Enn + Ep + Enである。

  - Epp = 正のエネルギーをもつPのエネルギーの総和で正の値を取る
  - Enn = 負のエネルギーを持つNのエネルギーの総和で負の値を取る
  - Ep  = 素粒子muの全数 * (+e)で正の値を取る
  - En  = 素粒子niの全数 * (-e)で負の値を取る

## 粒子間の力
- 同種の粒子P同士の間、もしくはN同士の間には斥力が生じる
- その力は粒子間の距離の二乗に反比例し、それぞれの持つエネルギーに比例する
  - Fr = - ρ1 * 1/r^2
    - Frは同種の粒子の間に働くrepulsiveな力である
    - ρ1は数値の係数である
    - rは粒子間の距離である

- 異種の粒子PとNの間には引力が生じる
- その力は粒子間の距離の四乗に反比例し、それぞれの持つエネルギーに比例する
  - Fa = + ρ2 * 1/r^4
    - Faは同種の粒子の間に働くattractiveな力である
    - ρ2は数値の係数である
    - rは粒子間の距離である


## 粒子の誕生
- P/N粒子の大きさに比してr_rate倍の領域に注目する
- その領域のエネルギー量、すなわちE+=e*mu素粒子の数
- 素粒子ruの密度に応じて生成された粒子Pの持つエネルギーが決定される
- つまり任意の点(x0,y0)に対して
   (x-x0)^2 + (y-y0)^2 < R*r_rate
   を満たす領域内に存在する
   　素粒子muの数がXより大きい場合,素粒子muの全数分のエネルギーを持つ粒子Pが発生する
   　素粒子niの数がXより大きい場合,素粒子niの全数分のエネルギーを持つ粒子Nが発生する
- 粒子Pは正のエネルギーを持つ粒子となる
- 粒子Nは負のエネルギーを持つ粒子となる

## 初速度の決定
- 粒子が生成される地点(x0, y0)を中心とした半径R*r_rateの円内の素粒子の分布を考える
- 円内を n 個の扇形の領域に分割する
- 各扇形領域内の素粒子の数を数え、エネルギー分布を計算する
- i番目の扇形領域内の素粒子の数をN(i)とする
- 各扇形領域の中心方向の単位ベクトルを(cos(θ(i)), sin(θ(i)))とする
- エネルギー分布から初期速度単位ベクトル(Vx, Vy)/|V|を下記の要領で計算する
  - Vx = Σ(1<=i<=n) {N(i) * cos(θ(i))}
  - Vy = Σ(1<=i<=n) {N(i) * sin(θ(i))}
- 粒子Pの場合は正のエネルギー0<Eを持つので、V=root(2*E/m) 　で定義され初期速度を持つことになる
- 粒子Nの場合は負のエネルギーE<0を持つので -V=root(2*-E/m)　で定義され初期速度を持つことになる


## 粒子の生活
- 生存を開始した瞬間から粒子は運動を開始する
- 直線運動を開始したのちは粒子間の斥力と引力にさらされる

## エネルギー減少による粒子の消滅
- P粒子はEmin以下のエネルギーになると消滅する
- N粒子は-Emin以上のエネルギーになると消滅する
- P粒子のエネルギー量は速度の大きさよりE=m*|V|^2で決定される
- N粒子のエネルギー量は速度の大きさよりE=-m*|V|^2で決定される
- 粒子が消滅する瞬間保持しているエネルギー量に応じてmuもしくはqi素粒子が放出される
- 残っていたエネルギーは全て素粒子に換算される。
- P粒子であれば正のエネルギーを持つのでmu素粒子を発生させる
- N粒子であれば負のエネルギーを持つのでqi素粒子を発生させる
- 素粒子が発生する位置は消滅した粒子の半径Ｒの内部でランダムな位置に発生する

## N、P粒子結合による粒子の消滅
- NとPの粒子が結合したときに消滅する
- 結合は引力によって相互の距離がrminに達したときに消滅する
- 二つの粒子の差として計算されるエネルギーは全て素粒子に換算される
- P粒子の正のエネルギーとN粒子の負のエネルギーの和ΔEが正であればmu素粒子を発生させる
- その時のmu素粒子の数はΔE/eの数だけ発生する
- P粒子の正のエネルギーとN粒子の負のエネルギーの和が負であればqi素粒子を発生させる
- その時のqi素粒子の数は-ΔE/eの数だけ発生する
- 素粒子は系のランダムな位置に発生する

# 粒子の運動方程式
- すべての同種の粒子間、全ての異種の粒子間に力が働いている計算を以下の方針で軽減する
  - 斥力に対しては対象の粒子から半径Rrの円内に所属する同種のNb個の粒子のみを考慮対象とする
  - 引力に対しては対象の粒子から半径Raの円内に所属する異種のNc個の粒子のみを考慮対象とする
  - ある粒子に注目しx方向、y方向の運動方程式は以下の通りとなる
    - m*ax = ρ2 * ΣRa(1<k<Nc) {cos(θ(k))/r(k)^4} - ρ1 * ΣRr(1<j<Nb) {cos(θ(j))/r(j)^2)} -f*vx
    - m*ay = ρ2 * ΣRa(1<k<Nc) {sin(θ(k))/r(k)^4} - ρ1 * ΣRr(1<j<Nb) {cos(θ(j))/r(j)^2)} -f*vy
      - ただし
	- x,yを注目した粒子のx,y座標とする
	- vx,vyを注目した粒子のx,y方向のそれぞれの速度とする
        - ax,ayを注目した粒子のx,y方向のそれぞれの加速度とする
	- ΣRa(1<k<Nc){}は{}内の式を半径Raの円内に所属する全粒子について添字kで繰り返し加算した合計値
	- ΣRr(1<j<Nb){}は{}内の式を半径Rrの円内に所属する全粒子について添字jで繰り返し加算した合計値
	- fは摩擦係数
	- 注目する粒子と計算対象であるk番目の異種粒子を結ぶ線分に対して
           - r(k)を線分の長さとする
           - θ(k)を線分とx座標がなす角度とする
	- 同様に、注目する粒子と計算対象であるj番目の同種粒子を結ぶ線分に対して
           - r(j)を線分の長さとする
           - θ(j)を線分とx座標がなす角度とする

## 粒子の斥力と引力を計算するためのk-d treeを用いた近傍探索の利用
- 斥力、引力の働く異種、同種の粒子を特定するためにk-d treeを用いた近傍探索を利用


## 粒子の衝突
- 粒子の衝突判定は行わない
- よって、粒子が衝突した際の結合、分解も発生しない
- 粒子には生存戦略が存在し生存期間を伸ばそうとする

# 素粒子の運動
- 素粒子の動きを定義するために、粒子の運動に影響を受けるベクトル場を導入する
- 系全体に対して、初期状態でゼロのベクトル場を定義
- 各時間ステップにおいて、以下の手順でベクトル場を更新
  a. 粒子の現在位置と前の時間ステップの位置から、粒子の移動ベクトルを計算
  b. 粒子の移動ベクトルに基づいてベクトル場を更新。
  c. 粒子の軌跡に沿ってベクトル場が変化するように、以下の方程式を用いる

    F(x, y, t+1) = α * F(x, y, t) + β * Σ(k=1 to M) {v(k) * e^(-d(k)^2 / (2*σ^2))}

      - F(x, y, t)は時刻tにおける位置(x, y)でのベクトル場
      - αは減衰係数 (0 < α < 1)
      - βは粒子の速度の影響の強さを表す係数
      - M は粒子の総数, すなわちその時点に存在する全粒子の運動を考慮するという意
      - v(k)はk番目の粒子の速度ベクトル
      - eは自然対数の底
      - d(k)は位置(x, y)とk番目の粒子の位置との距離
      - σはガウス関数の広がりを表すパラメータ


## 素粒子の移動
- 素粒子の移動はベクトル場に従い各時間ステップにおいて素粒子の位置を以下の方程式で更新
  - x(t+1) = x(t) + γ * F(x(t), y(t), t)_x
  - y(t+1) = y(t) + γ * F(x(t), y(t), t)_y
    - (x(t), y(t))は時刻tにおける素粒子の位置
    - γは素粒子の移動速度を調整するための係数
    - F(x(t), y(t), t)_xは時刻tにおける位置(x(t), y(t))でのベクトル場のx成分
    - F(x(t), y(t), t)_yは時刻tにおける位置(x(t), y(t))でのベクトル場のy成分
    - ただし素粒子の速度root{(x(t+1)-x(t)^2+(y(t+1)-y(t)^2}は上限cとする

## 素粒子のベクトル場を計算するための空間離散化
- 系を格子状に分割し、格子点上でのみベクトル場を計算する。
- 格子の解像度をΔとする。
- 素粒子の位置は、近傍の格子点の値から線形補間を用いて計算する。
- 素粒子の位置を(x, y)とし、近傍の格子点を(x1, y1)、(x2, y1)、(x1, y2)、(x2, y2)とする。
- 素粒子の位置でのベクトル場の値F(x, y)は以下の式で計算する。
  - F(x, y) = (1-u)(1-v)F(x1, y1) + u(1-v)F(x2, y1) + (1-u)vF(x1, y2) + uvF(x2, y2)
  - u = (x - x1) / Δ
  - v = (y - y1) / Δ

## 粒子から受けるベクトル場の更新を影響範囲を限定することにより計算量を削減
- 粒子からの影響が及ぶベクトル場の範囲を限定する
- 粒子を中心とした半径Reの円内の格子点でのみ、ベクトル場の更新を行う。
- 更新式は以下のように変更する。
- F(x, y, t+1) = α * F(x, y, t) + β * Σ(k∈S) {v(k) * e^(-d(k)^2 / (2*σ^2))}
- S は粒子を中心とした半径Reの円内に含まれる粒子の集合
- d(k)は格子点(x, y)とk番目の粒子の位置との距離



# プログラミング方針
## 開発環境
- webpack, npmを利用して開発環境を構築します。
- JavaScriptはES6の関数型の最新のプログラミングスタイルを採用します


## 関数型プログラミングの利用:
- 純粋関数を利用して、粒子システムの挙動をモデル化。システムの状態を一貫して管理し、副作用を避けることで、予測可能で再利用可能なコードを目指します。

## 手続き型プログラミングの利用:
- canvasに対しての操作については必ず変化が生じるので純粋関数での利用にはならない
- 特定の状態更新や操作を直感的に記述。粒子の運動や結合プロセスを順序立てて表現します。

# 初期状態
- 系にランダムにNp個のp粒子、Nn個のn粒子を配置する
- Np個のP粒子は(0<E(i)<Emax)の間のランダムなエネルギー量を持つ
- Nn個のN粒子は(-Emax<-E(j)<0)の間のランダムな負のエネルギー量を持つ
- Nq個のmu素粒子の数、Nn個のqi素粒子の数が存在する

# 描画
## 粒子の描画
- 粒子P, Nともにエネルギーがゼロの状態を COLOR_ZEROとする
- 粒子Pのエネルギーを表す色をCOLOR_PositiveとCOLOR_ZEROの間の色を取る。線形補完とする
- 粒子Nのエネルギーを表す色をCOLOR_NegativeとCOLOR_ZEROの間の色を取る。線形補完とする
- 粒子P, Nともに線の色を無色、かつ、線の太さを0とする
- 粒子Ｐの描画色がCOLOR_Positiveを取るのはエネルギーの初期値が生成の閾値の２倍以上での粒子生成時とする
  - このルールは初期状態で粒子生成された場合も同様とする
- 粒子Nの描画色がCOLOR_Negativeを取るのはエネルギーの初期値が生成の閾値の-２倍以下での粒子生成時とする
  - このルールは初期状態で粒子生成された場合も同様とする
 
  
## 素粒子の描画
- 素粒子muを表す色をCOLOR_mu
- 素粒子qiを表す色をCOLOR_qi
- 点で描画、大きさは１
- 素粒子の描画を行うか行わないかのスイッチDRAW_qとする

#定数の値
- 定数の値は全てセットとして扱い、複数のセットを定義できるようにする
- シミュレーション開始時にはどのセットを利用するかを指定できるようにする
- 下記に示すのは1番目のセットである。
- 同内容のセットを2番目のセットとして定義する
- これをまずは変更してシミュレーションの様子を確認する

- Δt   = 0.1     // シミュレーション実施の時間ステップの大きさ
- Lx   = 400;    // 空間の横の長さでありキャンバスの横の長さ
- Ly   = 400;    // 空間の縦の長さでありキャンバスの縦の長さ
- m    = 1.0;    // 粒子P,Nの重さ
- R    = 3.0;    // 粒子P,Nの半径
- Np0  = 10;     // 初期状態のP粒子の数
- Nn0  = 5;      // 初期状態のN粒子の数
- e    = 2;      // 素粒子のエネルギーの大きさ
- Nm   = 5000;    // mu素粒子の数
- Nq   = 5000;    // qi素粒子の数
- X    = 100;     // 粒子発生の閾値
- Emin = 1;
- rmin = 4;
- c    = 20;
- Δ    = 1.0;     // Δ　≦　R/2がいいらしい
- σ    = 5.0;     // 10,5,2　　　　右に行くほど局所的
- β    = 0.5;     // 0.1,0.5,1.0  右に行くほど局所的
- γ    = 1.0;   
- Re   = 20;     // ベクトル場が粒子から影響を受ける範囲の大きさ
- ρ1   = 10.0;   // 斥力定数
- ρ2   = 1000.0; // 引力定数
- f    = 20;     // 摩擦係数
- Ra   = 10;     // 引力を計算するときの円の半径
- Rr   = 30;     // 斥力を計算するときの円の半径
- DRAW_q=true;  // 素粒子の描画
- k = 10;       // 初速度を決定する比例定数

## 色の定義

- COLOR_Positive: RGB値：255, 0, 0 または "red" など、プログラミング環境に適した方法で定義すること
- COLOR_Negative: RGB値：0, 0, 255 または "blue" など、プログラミング環境に適した方法で定義すること
- COLOR_ZERO: RGB値：255, 255, 255 または "white" など、プログラミング環境に適した方法で定義すること
- COLOR_mu: RGB値：255, 165, 0 または "orange" など、プログラミング環境に適した方法で定義すること
- COLOR_qi: RGB値：0, 128, 0 または "green" など、プログラミング環境に適した方法で定義すること


# サンプルコード
## 二次元空間にNこの粒子をランダムに配置するためのJavaScript
```
const N = 100; // 粒子の数
const R = 1000; // 空間の大きさ
// N個の粒子の位置をランダムに生成する関数
const generatePositions = (n, r) => {
    const positions = [];
    for (let i = 0; i < n; i++) {
        const x = Math.random() * r; // 0からRまでのランダムな数値
        const y = Math.random() * r; // 0からRまでのランダムな数値
        positions.push([x, y]);
    }
    return positions;
};
const positions = generatePositions(N, R);
console.log(positions);
```

